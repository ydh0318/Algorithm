n = int(input())

'''
    마지막 계단은 무조건 밟아야 함.
    -> 마지막 계단을 밟고 시작해서, 그 다음 계단부터 최댓값을 갱신함.
    
    dp[0][0] = 마지막 계단에서 점수를 고려했을 때 지금까지 몇번을 연속으로 밟았는가?
    두번째 전을 밟은 것만 고려하지 않으면 됨?
    만약 두번째 전것을 밟았다면, 밟은것과 밟지 않은것을 따로 기록함.
'''

'''
    계단을 밟는 규칙 -> 한 계단씩 또는 두 계단씩 오를 수 있음.
    열 : 0 -> 안밟음, 1 -> 밟음, 2 -> 이전거 밟음
    
    첫번째(마지막) 계단을 무조건 밟음
    d[1][1] = 20
    
    d[2][0] -> 이번 계단 안 밟음 -> 이전 이전 계단은 무조건 밟아야 함
    d[2][0] = max(d[0][1], d[0][2], d[1][1], d[1][2])
    
    d[2][1] -> 2번째 계단을 고려할 때, 이전의 계단을 밟지 않았다고 가정함.
    d[2][0] = max(d[0][1], d[0][2]) + 현재 계단 값
    
    d[2][2] -> 이전 계단 밟은것 고려
    d[2][2] -> d[1][1] + 현재 계단 값
'''

steps = []
for _ in range(n):
    steps.append(int(input()))
    
steps.append(0)
steps.reverse()

dp = [[0] * 3 for _ in range(len(steps))]

if n == 1:
    print(steps[-1])
elif n == 2:
    print(sum(steps))
elif n > 2:
    dp[1][1] = steps[1]
    dp[2][0] = dp[1][1]
    dp[2][1] = dp[1][1]
    dp[2][2] = dp[1][1] + steps[2]
    for i in range(3, len(steps)):
        # 이번 계단 안 밟음 -> 이전 이전 계단은 무조건 밟아야 함
        dp[i][0] = dp[i-1][2]
        # 이전의 계단을 밟지 않았다고 가정함.
        dp[i][1] = max(dp[i-2][1], dp[i-2][2]) + steps[i]
        # 이전 계단을 밟은것을 고려함
        dp[i][2] = dp[i-1][1] + steps[i]
    print(max(dp[n]))

    